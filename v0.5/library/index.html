<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · RegularizationTools.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="RegularizationTools.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">RegularizationTools.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li><a class="tocitem" href="../theory/theory/">Theory</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Constructor-Functions"><span>Constructor Functions</span></a></li><li><a class="tocitem" href="#Solvers"><span>Solvers</span></a></li><li><a class="tocitem" href="#Validators"><span>Validators</span></a></li><li><a class="tocitem" href="#Generic-Functions"><span>Generic Functions</span></a></li><li><a class="tocitem" href="#High-Level-API"><span>High-Level API</span></a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mdpetters/RegularizationTools.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Types"><a class="docs-heading-anchor" href="#Data-Types">Data Types</a><a id="Data-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Types" title="Permalink"></a></h1><h3 id="RegularizationProblem"><a class="docs-heading-anchor" href="#RegularizationProblem">RegularizationProblem</a><a id="RegularizationProblem-1"></a><a class="docs-heading-anchor-permalink" href="#RegularizationProblem" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.RegularizationProblem" href="#RegularizationTools.RegularizationProblem"><code>RegularizationTools.RegularizationProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegularizationProblem</code></pre><p>This data type contains the cached matrices used in the inversion. The problem is  initialized using the constructor <a href="#setupRegularizationProblem">setupRegularizationProblem</a> with the design matrix  A and the the Tikhonv matrix L as inputs. The hat quantities, e.g. Ā, is the calculated design matrix in standard form. ĀĀ, Āᵀ, F̄ are precomputed to speed up repeating inversions with different data. L⁺ₐ is cached to speed up the repeated conversion of  data <a href="#to_standard_form">to_standard_form</a> and <a href="#to_general_form">to_general_form</a></p><pre><code class="nohighlight hljs">Ā::Matrix{Float64}     # Standard form of design matrix
A::Matrix{Float64}     # General form of the design matrix (n×p)
L::Matrix{Float64}     # Smoothing matrix (n×p)
ĀĀ::Matrix{Float64}    # Cached value of Ā&#39;Ā for performance
Āᵀ::Matrix{Float64}    # Cached value of Ā&#39; for performance
F̄::SVD                 # Cached SVD decomposition of Ā 
Iₙ::Matrix{Float64}    # Cached identity matrix n×n
Iₚ::Matrix{Float64}    # Cached identity matrix p×p
L⁺ₐ::Matrix{Float64}   # Cached A-weighted generalized inverse of L(standard-form conversion)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/RegularizationTools.jl#L35-L54">source</a></section></article><h3 id="RegularizatedSolution"><a class="docs-heading-anchor" href="#RegularizatedSolution">RegularizatedSolution</a><a id="RegularizatedSolution-1"></a><a class="docs-heading-anchor-permalink" href="#RegularizatedSolution" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.RegularizedSolution" href="#RegularizationTools.RegularizedSolution"><code>RegularizationTools.RegularizedSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegularizatedSolution</code></pre><p>Data tpye to store the optimal solution x of the inversion. λ is the optimal λ used  solution is the raw output from the Optim search.</p><pre><code class="nohighlight hljs">x::AbstractVector
λ::AbstractFloat
solution::Optim.UnivariateOptimizationResults</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/RegularizationTools.jl#L69-L78">source</a></section></article><h3 id="Domain"><a class="docs-heading-anchor" href="#Domain">Domain</a><a id="Domain-1"></a><a class="docs-heading-anchor-permalink" href="#Domain" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.Domain" href="#RegularizationTools.Domain"><code>RegularizationTools.Domain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Domain{T1&lt;:Any,T2&lt;:Number,T3&lt;:Any}</code></pre><p>Functor to map from a domain characterized by a list of setpoints [s], each  associated with a list of numerical values [x] to a query value q. </p><pre><code class="nohighlight hljs">s::AbstractVector{T1}
x::AbstractVector{T2}
q::T3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/RegularizationTools.jl#L85-L94">source</a></section></article><h2 id="Constructor-Functions"><a class="docs-heading-anchor" href="#Constructor-Functions">Constructor Functions</a><a id="Constructor-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor-Functions" title="Permalink"></a></h2><h3 id="Tikhonov-Matrix"><a class="docs-heading-anchor" href="#Tikhonov-Matrix">Tikhonov Matrix</a><a id="Tikhonov-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Tikhonov-Matrix" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.Γ" href="#RegularizationTools.Γ"><code>RegularizationTools.Γ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Γ(A::AbstractMatrix, order::Int)</code></pre><p>Return the smoothing matrix L for Tikhonov regularization based on the size of design matrix A.  Order can be 0, 1, ..., n. Code to generate matrix is based on Jonathan Stickel&#39;s suggestion posted in Issue #7.</p><pre><code class="language-julia hljs">L = Γ(A, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/solvers.jl#L1-L11">source</a></section></article><h3 id="setupRegularizationProblem"><a class="docs-heading-anchor" href="#setupRegularizationProblem">setupRegularizationProblem</a><a id="setupRegularizationProblem-1"></a><a class="docs-heading-anchor-permalink" href="#setupRegularizationProblem" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.setupRegularizationProblem" href="#RegularizationTools.setupRegularizationProblem"><code>RegularizationTools.setupRegularizationProblem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setupRegularizationProblem(A::AbstractMatrix, order::Int)</code></pre><p>Precompute matrices to initialize Reguluarization Problem based on design matrix A and  zeroth, first, or second order difference operator. See Hanson (1998) and source code for details.</p><p>Example Usage</p><pre><code class="language-julia hljs">Ψ = setupRegularizationProblem(A, 0) # zeroth order problem
Ψ = setupRegularizationProblem(A, 2) # second order problem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/solvers.jl#L350-L362">source</a></section><section><div><pre><code class="nohighlight hljs">setupRegularizationProblem(A::AbstractMatrix, L::AbstractMatrix)</code></pre><p>Precompute matrices to initialize Reguluarization Problem based on design matrix and  Tikhonov smoothing matrix. See Hansen (1998, Eq. 2.35)</p><p>Example Usage</p><pre><code class="language-julia hljs">Ψ = setupRegularizationProblem(A, L) </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/solvers.jl#L366-L376">source</a></section></article><h3 id="to_standard_form"><a class="docs-heading-anchor" href="#to_standard_form">to_standard_form</a><a id="to_standard_form-1"></a><a class="docs-heading-anchor-permalink" href="#to_standard_form" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.to_standard_form" href="#RegularizationTools.to_standard_form"><code>RegularizationTools.to_standard_form</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_standard_form(Ψ::RegularizationProblem, b::AbstractVector)</code></pre><p>Converts vector b to standard form using (Hansen, 1998)</p><p>Example Usage (Regular Syntax)</p><pre><code class="language-julia hljs">b̄ = to_standard_form(Ψ, b)</code></pre><p>Example Usage (Lazy Syntax)</p><pre><code class="language-julia hljs">b̄ = @&gt;&gt; b to_standard_form(Ψ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/solvers.jl#L31-L45">source</a></section><section><div><pre><code class="nohighlight hljs">to_standard_form(Ψ::RegularizationProblem, b::AbstractVector, x₀::AbstractVector)</code></pre><p>Converts vector b and x₀ to standard form using (Hansen, 1998)</p><p>Example Usage (Regular Syntax)</p><pre><code class="language-julia hljs">b̄ = to_standard_form(Ψ, b, x₀)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/solvers.jl#L48-L57">source</a></section></article><h3 id="to_general_form"><a class="docs-heading-anchor" href="#to_general_form">to_general_form</a><a id="to_general_form-1"></a><a class="docs-heading-anchor-permalink" href="#to_general_form" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.to_general_form" href="#RegularizationTools.to_general_form"><code>RegularizationTools.to_general_form</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_general_form(Ψ::RegularizationProblem, b::AbstractVector, x̄::AbstractVector)</code></pre><p>Converts solution <span>$\bar {\rm x}$</span> computed in standard form back to general form  <span>${\rm x}$</span> using (Hansen, 1998).</p><p class="math-container">\[{\rm x}={\rm {\bf L^{+}_A}\bar{x} + x\_0}\]</p><p>where the matrices and vectors are defined in <a href="#RegularizationProblem">RegularizationProblem</a></p><p>Example Usage (Regular Syntax)</p><pre><code class="language-julia hljs">x = to_general_form(Ψ, b, x̄) </code></pre><p>Example Usage (Lazy Syntax)</p><pre><code class="language-julia hljs">x = @&gt;&gt; x̄ to_general_form(Ψ, b) </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/solvers.jl#L61-L82">source</a></section></article><h2 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h2><h3 id="solve"><a class="docs-heading-anchor" href="#solve">solve</a><a id="solve-1"></a><a class="docs-heading-anchor-permalink" href="#solve" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.solve" href="#RegularizationTools.solve"><code>RegularizationTools.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve(Ψ::RegularizationProblem, b̄::AbstractVector, λ::AbstractFloat)</code></pre><p>Compute the Tikhonov solution for problem Ψ in standard form for regularization parameter λ and using zero as initial guess. Returns a vector <span>$\rm {\bar x}_\lambda$</span>. </p><p class="math-container">\[{\rm x_{\lambda}}=\left({\rm {\bf \bar A}^{T}}{\rm {\bf \bar A}}+\lambda^{2}{\rm {\bf I}}\right)^{-1} 
{\rm {\bf {\bar A}}^{T}}{\rm {\bar b}} \]</p><p>Example Usage (Standard Syntax)</p><pre><code class="language-julia hljs"># A is a Matrix and b is a response vector. 
Ψ = setupRegularizationProblem(A, 1)     # Setup problem
b̄ = to_standard_form(Ψ, b)               # Convert to standard form
x̄ = solve(A, b̄, 0.5)                     # Solve the equation
x = to_general_form(Ψ, b, x̄)             # Convert back to general form</code></pre><p>Example Usage (Lazy Syntax)</p><pre><code class="language-julia hljs"># A is a Matrix and b is a response vector. 
Ψ = setupRegularizationProblem(A, 1)     # Setup problem
b̄ = @&gt;&gt; b to_standard_form(Ψ)            # Convert to standard form
x̄ = solve(A, b̄, 0.5)                     # Solve the equation
x = @&gt;&gt; x̄ to_general_form(Ψ, b)          # Convert back to general form</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/solvers.jl#L87-L114">source</a></section><section><div><pre><code class="nohighlight hljs">solve(Ψ::RegularizationProblem, b̄::AbstractVector, x̄₀::AbstractVector, λ::AbstractFloat)</code></pre><p>Compute the Tikhonov solution for problem Ψ in standard form for regularization parameter λ and using x̄₀ as initial guess. </p><p class="math-container">\[{\rm x_{\lambda}}=\left({\rm {\bf \bar A}^{T}}{\rm {\bf \bar A}}+\lambda^{2}{\rm {\bf I}}\right)^{-1} 
\left({\rm {\bf {\bar A}}^{T}}{\rm {\bar b}} + \lambda^2 {\rm {\bar x}}_0 \right)\]</p><p>Example Usage (Standard Syntax)</p><pre><code class="language-julia hljs"># A is a Matrix and b is a response vector. 
Ψ = setupRegularizationProblem(A, 2)     # Setup problem
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)       # Convert to standard form
x̄ = solve(A, b̄, x̄₀, 0.5)                 # Solve the equation
x = to_general_form(Ψ, b, x̄)             # Convert back to general form</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/solvers.jl#L121-L140">source</a></section><section><div><pre><code class="nohighlight hljs">function solve(
    Ψ::RegularizationProblem,
    b::AbstractVector;
    alg = :gcv_svd,
    λ₁ = 0.0001,
    λ₂ = 1000.0,
)</code></pre><p>Find the optimum regularization parameter λ between [λ₁, λ₂] using the algorithm alg. Choices for algorithms are</p><pre><code class="nohighlight hljs">    :gcv_tr - generalized cross validation using the trace formulation (slow)
    :gcv_svd - generalized cross validation using the SVD decomposition (fast)
    :L_curve - L-curve algorithm </code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The gcv_svd algorithm is fastest and most stable. The L_curve algorithn is sensitive to the upper  and lower bound. Specify narrow upper and lower bounds to obtain a good solution.</p></div></div><p>The solve function takes the original data, converts it to standard form, performs the search within the specified bounds and returns a <a href="#RegularizatedSolution">RegularizatedSolution</a></p><p>Example Usage (Standard Syntax)</p><pre><code class="language-julia hljs"># A is a Matrix and b is a response vector. 
Ψ = setupRegularizationProblem(A, 2)     # Setup problem
sol = solve(Ψ, b)                        # Solve it</code></pre><p>Example Usage (Lazy Syntax)</p><pre><code class="language-julia hljs"># A is a Matrix and b is a response vector. 
sol = @&gt; setupRegularizationProblem(A, 1) solve(b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/solvers.jl#L147-L183">source</a></section><section><div><pre><code class="nohighlight hljs">function solve(
    Ψ::RegularizationProblem,
    b::AbstractVector,
    x₀::AbstractVector;
    alg = :gcv_svd,
    λ₁ = 0.0001,
    λ₂ = 1000.0,
)</code></pre><p>Same as above, but includes an initial guess x₀. Example Usage (Lazy Syntax)</p><pre><code class="language-julia hljs"># A is a Matrix and b is a response vector. 
sol = @&gt; setupRegularizationProblem(A, 1) solve(b, x₀, alg = :L_curve, λ₂ = 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/solvers.jl#L208-L223">source</a></section><section><div><pre><code class="nohighlight hljs">function solve(
    Ψ::RegularizationProblem, 
    b::AbstractVector,
    lower::AbstractVector, 
    upper::AbstractVector;
    kwargs...
)</code></pre><p>Constraint minimization of <a href="#RegularizationProblem">RegularizationProblem</a> Ψ, with observations b and upper and lower bounds for each xᵢ.</p><p>The function computes the algebraic solution using <code>solve(Ψ, b; kwargs...)</code>, truncates the solution at the upper and lower bounds and uses this solution as initial condition for the minimization problem using a Least Squares numerical solver. The returned solution is using the regularization parameter λ obtained from the algebraic solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/solvers.jl#L250-L266">source</a></section><section><div><pre><code class="nohighlight hljs">function solve(
    Ψ::RegularizationProblem, 
    b::AbstractVector,
    x₀::AbstractVector,
    lower::AbstractVector, 
    upper::AbstractVector;
    kwargs...
)</code></pre><p>Constraint minimization of <a href="#RegularizationProblem">RegularizationProblem</a> Ψ, with observations b, intial  guess x₀ and upper and lower bounds for each xᵢ.</p><p>The function computes the algebraic solution using <code>solve(Ψ, b; kwargs...)</code>, truncates the solution at the upper and lower bounds and uses this solution as initial condition for the minimization problem using a Least Squares numerical solver. The returned solution is using the regularization parameter λ obtained from the algebraic solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/solvers.jl#L277-L295">source</a></section></article><h2 id="Validators"><a class="docs-heading-anchor" href="#Validators">Validators</a><a id="Validators-1"></a><a class="docs-heading-anchor-permalink" href="#Validators" title="Permalink"></a></h2><h3 id="GCV"><a class="docs-heading-anchor" href="#GCV">GCV</a><a id="GCV-1"></a><a class="docs-heading-anchor-permalink" href="#GCV" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.gcv_tr" href="#RegularizationTools.gcv_tr"><code>RegularizationTools.gcv_tr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gcv_tr(Ψ::RegularizationProblem, b̄::AbstractVector, λ::AbstractFloat)</code></pre><p>Compute the <a href="../theory/theory/#Generalized-Cross-Validation">Generalized Cross Validation</a> using the trace term. Requires that the  vector b̄ is in standard form.</p><p class="math-container">\[V(\lambda)=\frac{n\left\lVert ({\bf {\rm {\bf {\bf I}-}{\bf \bar {A}_{\lambda}})
{\bar{\rm b}}}}\right\rVert _{2}^{2}}{tr({\rm {\bf I}-{\rm {\bar {\bf A}_{\lambda}})}^{2}}}\]</p><p>Example Usage</p><pre><code class="language-julia hljs">using Underscores

Ψ = setupRegularizationProblem(A, 1)           # Setup problem
b̄ = to_standard_form(Ψ, b)                     # Convert to standard form
Vλ = gcv_tr(Ψ, b̄, 0.1)                         # V(λ) single λ value
Vλ = @_ map(gcv_tr(Ψ, b̄, _), [0.1, 1.0, 10.0]) # V(λ) for array of λ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/validators.jl#L1-L21">source</a></section><section><div><pre><code class="nohighlight hljs">gcv_tr(
    Ψ::RegularizationProblem,
    b̄::AbstractVector,
    x̄₀::AbstractVector,
    λ::AbstractFloat,
)</code></pre><p>Compute the <a href="../theory/theory/#Generalized-Cross-Validation">Generalized Cross Validation</a> using the trace term and intial guess.  Requires that the vectors b̄ and x̄₀ are in standard form.</p><p class="math-container">\[V(\lambda)=\frac{n\left\lVert {\bf {\rm {\bf \bar{A}}{\rm \bar{x}{}_{\lambda}}-
{\rm \bar{b}}}}\right\rVert _{2}^{2}}{tr({\rm {\bf I}-{\rm {\bar {\bf A}_{\lambda}})}^{2}}}\]</p><p>Example Usage</p><pre><code class="language-julia hljs">using Underscores

Ψ = setupRegularizationProblem(A, 1)               # Setup problem
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)                 # Convert to standard form
Vλ = gcv_tr(Ψ, b̄, x̄₀, 0.1)                         # V(λ) single λ value
Vλ = @_ map(gcv_tr(Ψ, b̄, x̄₀, _), [0.1, 1.0, 10.0]) # V(λ) for array of λ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/validators.jl#L30-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.gcv_svd" href="#RegularizationTools.gcv_svd"><code>RegularizationTools.gcv_svd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gcv_svd(Ψ::RegularizationProblem, b̄::AbstractVector, λ::AbstractFloat)</code></pre><p>Compute the <a href="../theory/theory/#Generalized-Cross-Validation">Generalized Cross Validation</a> using the trace term using the SVD  algorithm. Requires that the vector b̄ is in standard form.</p><p>Example Usage</p><pre><code class="language-julia hljs">using Underscores

Ψ = setupRegularizationProblem(A, 1)            # Setup problem
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)              # Convert to standard form
Vλ = gcv_svd(Ψ, b̄, x̄₀, 0.1)                     # V(λ) single λ value
Vλ = @_ map(gcv_svd(Ψ, b̄, _), [0.1, 1.0, 10.0]) # V(λ) for array of λ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/validators.jl#L69-L84">source</a></section><section><div><pre><code class="nohighlight hljs">gcv_svd(
    Ψ::RegularizationProblem,
    b̄::AbstractVector,
    x̄₀::AbstractVector,
    λ::AbstractFloat,
)</code></pre><p>Compute the <a href="../theory/theory/#Generalized-Cross-Validation">Generalized Cross Validation</a> using the SVD algorithm and intial guess.  Requires that the vectors b̄ and x̄₀ are in standard form.</p><p>Example Usage</p><pre><code class="language-julia hljs">using Underscores

Ψ = setupRegularizationProblem(A, 1)               # Setup problem
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)                 # Convert to standard form
Vλ = gcv_tr(Ψ, b̄, x̄₀, 0.1)                         # V(λ) single λ value
Vλ = @_ map(gcv_tr(Ψ, b̄, x̄₀, _), [0.1, 1.0, 10.0]) # V(λ) for array of λ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/validators.jl#L104-L124">source</a></section></article><h3 id="L-curve-Functions"><a class="docs-heading-anchor" href="#L-curve-Functions">L-curve Functions</a><a id="L-curve-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#L-curve-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.Lcurve_functions" href="#RegularizationTools.Lcurve_functions"><code>RegularizationTools.Lcurve_functions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Lcurve_functions(Ψ::RegularizationProblem, b̄::AbstractVector)</code></pre><p>Compute the L-curve functions to evaluate the norms L1, L2, and the curvature κ.  Requires that the vectors b̄ is in standard form.</p><p>Example Usage</p><pre><code class="language-julia hljs">Ψ = setupRegularizationProblem(A, 1)
b̄ = to_standard_form(Ψ, b)
L1norm, L2norm, κ = Lcurve_functions(Ψ, b̄)

L1norm.([0.1, 1.0, 10.0])    # L1 norm for λ&#39;s
L2norm.([0.1, 1.0, 10.0])    # L2 norm for λ&#39;s
κ.([0.1, 1.0, 10.0])         # L-curve curvature for λ&#39;s</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/validators.jl#L162-L179">source</a></section><section><div><pre><code class="nohighlight hljs">Lcurve_functions(Ψ::RegularizationProblem, b̄::AbstractVector, x̄₀::AbstractVector)</code></pre><p>Compute the L-curve functions to evaluate the norms L1, L2, and the curvature κ.  Requires that the vectors b̄ and x̄₀ are in standard form.</p><p>Example Usage</p><pre><code class="language-julia hljs">Ψ = setupRegularizationProblem(A, 1)
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)                 
L1norm, L2norm, κ = Lcurve_functions(Ψ, b̄, x̄₀)

L1norm.([0.1, 1.0, 10.0])    # L1 norm for λ&#39;s
L2norm.([0.1, 1.0, 10.0])    # L2 norm for λ&#39;s
κ.([0.1, 1.0, 10.0])         # L-curve curvature for λ&#39;s</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/validators.jl#L187-L203">source</a></section></article><h2 id="Generic-Functions"><a class="docs-heading-anchor" href="#Generic-Functions">Generic Functions</a><a id="Generic-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-Functions" title="Permalink"></a></h2><h3 id="designmatrix"><a class="docs-heading-anchor" href="#designmatrix">designmatrix</a><a id="designmatrix-1"></a><a class="docs-heading-anchor-permalink" href="#designmatrix" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.designmatrix" href="#RegularizationTools.designmatrix"><code>RegularizationTools.designmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">designmatrix(s::Any, q::Any, f::Function)::AbstractMatrix</code></pre><ul><li>s is an array of setpoints</li><li>q is an array of query points</li><li>f is a function that maps the functor <a href="#Domain">Domain</a> to a solution y</li></ul><p>The function to creates an array of domain nodes using the standard basis eᵢ of  the vector space. The setpoint or query point can be any abstract notion of the  input. For examples, a numerical value corresponding to a setting, a string label  ([&quot;bin A&quot;, &quot;bin B&quot;, ...), or a list of pixel coordinate [(1,1), (1,2), ...].  The function f must accept a single argument of type <a href="#Domain">Domain</a> and provide a  numerical mapping between input <span>$x$</span> and output <span>$y$</span> at query point <span>$q$</span>. The function designmatrix then returns a design matrix <span>$\mathbf{A}$</span> such that </p><p><span>$y = \mathbf{A}x$</span></p><p>where x is an array of numerical input values. In the case that [q] = [s], the  shortcut <code>designmatrix(s, f)</code> can be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/genericfunctions.jl#L1-L22">source</a></section></article><h3 id="forwardmodel"><a class="docs-heading-anchor" href="#forwardmodel">forwardmodel</a><a id="forwardmodel-1"></a><a class="docs-heading-anchor-permalink" href="#forwardmodel" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.forwardmodel" href="#RegularizationTools.forwardmodel"><code>RegularizationTools.forwardmodel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">forwardmodel(
    s::AbstractVector{T1},
    x::AbstractVector{T2},
    f::Function,
)::AbstractArray where {T1&lt;:Any,T2&lt;:Number}</code></pre><p>Forward model that maps numerical values [x] corresponding to  setpoints [s] to output [y], given the function f. The function f must  accept a single argument of type <a href="#Domain">Domain</a> and provide a  numerical mapping between input <span>$x$</span> and output <span>$y$</span> at query point <span>$q$</span>.</p><p>Note that the <a href="#designmatrix">designmatrix</a> and forward model are related</p><p>``` A = designmatrix(s, q, f) y1 = A*x</p><p>y2 = forwardmodel(s, x, q, f) y1 == y2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/genericfunctions.jl#L32-L52">source</a></section></article><h2 id="High-Level-API"><a class="docs-heading-anchor" href="#High-Level-API">High-Level API</a><a id="High-Level-API-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-API" title="Permalink"></a></h2><h3 id="invert"><a class="docs-heading-anchor" href="#invert">invert</a><a id="invert-1"></a><a class="docs-heading-anchor-permalink" href="#invert" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.invert" href="#RegularizationTools.invert"><code>RegularizationTools.invert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function invert(A::Matrix, b::Vector, method::InverseMethod; kwargs...)</code></pre><p>High-level API function to perform Tikhonov inversion. The function used  the algebraic data type InverseMethod</p><pre><code class="language-julia hljs">    @data InverseMethod begin 
        Lₖ(Int)                            # Pure Tikhonov
        Lₖx₀(Int,Vector)                   # with initial guess
        LₖB(Int,Vector,Vector)             # with bounds
        Lₖx₀B(Int,Vector,Vector,Vector)    # with initial guess + bounds
        LₖDₓ(Int,Float64)                  # with filter 
        Lₖx₀Dₓ(Int,Vector,Float64)         # with initial guess + filter 
        LₖDₓB(Int,Float64,Vector,Vector)   # with filter + bound
        Lₖx₀DₓB(Int,Vector,Float64,Vector,Vector) # with initial guess + filter + bound
    end</code></pre><p>to define the problem and then dispatches to the correct method. The kwargs... are passed to the solve function For example the standard way to perform second order regularization is </p><pre><code class="language-julia hljs">xλ = @&gt; setupRegularizationProblem(A, 2) solve(b) getfield(:x)</code></pre><p>this can alternativel written as </p><pre><code class="language-julia hljs">invert(A, b, Lₖ(2))</code></pre><p>where <code>Lₖ(2)</code> denotes the second order method. The method nomenclature is <code>Lₖ</code> for regularization order, <code>B</code> for bounded search, <code>x₀</code> for  initial condition, and <code>Dₓ</code> for the Huckle and Sedlacek (2012) two-step data based  regularization. The method data type takes hyper parameters to initialize the search.  Examples of method initializations are</p><pre><code class="language-julia hljs"># Hyper parameters 
k: order, lb: low bound, ub: upper bound, ε: noise level, x₀: initial guess
k, lb, ub, ε, x₀ = 2, zeros(8), zeros(8) .+ 50.0, 0.02, 0.5*N

xλ = invert(A, b, Lₖ(k); alg = :gcv_tr, λ₁ = 0.1)
xλ = invert(A, b, Lₖ(k); alg = :gcv_svd, λ₁ = 0.1)
xλ = invert(A, b, LₖB(k, lb, ub); alg = :L_curve, λ₁ = 0.1)
xλ = invert(A, b, Lₖx₀(k, x₀); alg = :L_curve, λ₁ = 0.1)
xλ = invert(A, b, Lₖx₀(k, x₀); alg = :gcv_tr)
xλ = invert(A, b, Lₖx₀(k, x₀); alg = :gcv_svd)
xλ = invert(A, b, Lₖx₀B(k, x₀, lb, ub); alg = :gcv_svd)
xλ = invert(A, b, LₖDₓ(k, ε); alg = :gcv_svd)
xλ = invert(A, b, LₖDₓB(k, ε, lb, ub); alg = :gcv_svd)
xλ = invert(A, b, Lₖx₀Dₓ(k, x₀, ε); alg = :gcv_svd)
xλ = invert(A, b, Lₖx₀DₓB(k, x₀, ε, lb, ub); alg = :gcv_svd)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/9f3cfb7686483b1b1257c9bdac31f412832362fd/src/invert.jl#L1-L56">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theory/theory/">« Theory</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 26 October 2021 19:04">Tuesday 26 October 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
