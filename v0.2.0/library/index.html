<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · RegularizationTools.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="RegularizationTools.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">RegularizationTools.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li><a class="tocitem" href="../theory/theory/">Theory</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Constructor-Functions"><span>Constructor Functions</span></a></li><li><a class="tocitem" href="#Solvers"><span>Solvers</span></a></li><li><a class="tocitem" href="#Validators"><span>Validators</span></a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mdpetters/RegularizationTools.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Types"><a class="docs-heading-anchor" href="#Data-Types">Data Types</a><a id="Data-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Types" title="Permalink"></a></h1><h3 id="RegularizationProblem"><a class="docs-heading-anchor" href="#RegularizationProblem">RegularizationProblem</a><a id="RegularizationProblem-1"></a><a class="docs-heading-anchor-permalink" href="#RegularizationProblem" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.RegularizationProblem" href="#RegularizationTools.RegularizationProblem"><code>RegularizationTools.RegularizationProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegularizationProblem</code></pre><p>This data type contains the cached matrices used in the inversion. The problem is  initialized using the constructor <a href="#setupRegularizationProblem">setupRegularizationProblem</a> with the design matrix  A and the the Tikhonv matrix L as inputs. The hat quantities, e.g. Ā, is the calculated design matrix in standard form. ĀĀ, Āᵀ, F̄ are precomputed to speed up repeating inversions with different data. L⁺ₐ is cached to speed up the repeated conversion of  data <a href="#to_standard_form">to_standard_form</a> and <a href="#to_general_form">to_general_form</a></p><pre><code class="language-none">Ā::Matrix{Float64}     # Standard form of design matrix
A::Matrix{Float64}     # General form of the design matrix (n×p)
L::Matrix{Float64}     # Smoothing matrix (n×p)
ĀĀ::Matrix{Float64}    # Cached value of Ā&#39;Ā for performance
Āᵀ::Matrix{Float64}    # Cached value of Ā&#39; for performance
F̄::SVD                 # Cached SVD decomposition of Ā 
Iₙ::Matrix{Float64}    # Cached identity matrix n×n
Iₚ::Matrix{Float64}    # Cached identity matrix p×p
L⁺ₐ::Matrix{Float64}   # Cached A-weighted generalized inverse of L(standard-form conversion)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/RegularizationTools.jl#L22-L41">source</a></section></article><h3 id="RegularizatedSolution"><a class="docs-heading-anchor" href="#RegularizatedSolution">RegularizatedSolution</a><a id="RegularizatedSolution-1"></a><a class="docs-heading-anchor-permalink" href="#RegularizatedSolution" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.RegularizedSolution" href="#RegularizationTools.RegularizedSolution"><code>RegularizationTools.RegularizedSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegularizatedSolution</code></pre><p>Data tpye to store the optimal solution x of the inversion. λ is the optimal λ used  solution is the raw output from the Optim search.</p><pre><code class="language-none">x::AbstractVector
λ::AbstractFloat
solution::Optim.UnivariateOptimizationResults</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/RegularizationTools.jl#L54-L63">source</a></section></article><h2 id="Constructor-Functions"><a class="docs-heading-anchor" href="#Constructor-Functions">Constructor Functions</a><a id="Constructor-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor-Functions" title="Permalink"></a></h2><h3 id="Tikhonov-Matrix"><a class="docs-heading-anchor" href="#Tikhonov-Matrix">Tikhonov Matrix</a><a id="Tikhonov-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Tikhonov-Matrix" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.Γ" href="#RegularizationTools.Γ"><code>RegularizationTools.Γ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Γ(A::AbstractMatrix, order::Int)</code></pre><p>Return the smoothing matrix L for zero, first and second order Tikhonov regularization  based on the size of design matrix A. Order can be 0, 1 or 2.</p><pre><code class="language-julia">L = Γ(A, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/solvers.jl#L1-L10">source</a></section></article><h3 id="setupRegularizationProblem"><a class="docs-heading-anchor" href="#setupRegularizationProblem">setupRegularizationProblem</a><a id="setupRegularizationProblem-1"></a><a class="docs-heading-anchor-permalink" href="#setupRegularizationProblem" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.setupRegularizationProblem" href="#RegularizationTools.setupRegularizationProblem"><code>RegularizationTools.setupRegularizationProblem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setupRegularizationProblem(A::AbstractMatrix, order::Int)</code></pre><p>Precompute matrices to initialize Reguluarization Problem based on design matrix A and  zeroth, first, or second order difference operator. See Hanson (1998) and source code for details.</p><p>Example Usage</p><pre><code class="language-julia">Ψ = setupRegularizationProblem(A, 0) # zeroth order problem
Ψ = setupRegularizationProblem(A, 2) # second order problem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/solvers.jl#L374-L386">source</a></section><section><div><pre><code class="language-none">setupRegularizationProblem(A::AbstractMatrix, L::AbstractMatrix)</code></pre><p>Precompute matrices to initialize Reguluarization Problem based on design matrix and  Tikhonov smoothing matrix. See Hansen (1998, Eq. 2.35)</p><p>Example Usage</p><pre><code class="language-julia">Ψ = setupRegularizationProblem(A, L) </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/solvers.jl#L390-L400">source</a></section></article><h3 id="to_standard_form"><a class="docs-heading-anchor" href="#to_standard_form">to_standard_form</a><a id="to_standard_form-1"></a><a class="docs-heading-anchor-permalink" href="#to_standard_form" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.to_standard_form" href="#RegularizationTools.to_standard_form"><code>RegularizationTools.to_standard_form</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_standard_form(Ψ::RegularizationProblem, b::AbstractVector)</code></pre><p>Converts vector b to standard form using (Hansen, 1998)</p><p>Example Usage (Regular Syntax)</p><pre><code class="language-julia">b̄ = to_standard_form(Ψ, b)</code></pre><p>Example Usage (Lazy Syntax)</p><pre><code class="language-julia">b̄ = @&gt;&gt; b to_standard_form(Ψ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/solvers.jl#L52-L66">source</a></section><section><div><pre><code class="language-none">to_standard_form(Ψ::RegularizationProblem, b::AbstractVector, x₀::AbstractVector)</code></pre><p>Converts vector b and x₀ to standard form using (Hansen, 1998)</p><p>Example Usage (Regular Syntax)</p><pre><code class="language-julia">b̄ = to_standard_form(Ψ, b, x₀)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/solvers.jl#L69-L78">source</a></section></article><h3 id="to_general_form"><a class="docs-heading-anchor" href="#to_general_form">to_general_form</a><a id="to_general_form-1"></a><a class="docs-heading-anchor-permalink" href="#to_general_form" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.to_general_form" href="#RegularizationTools.to_general_form"><code>RegularizationTools.to_general_form</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_general_form(Ψ::RegularizationProblem, b::AbstractVector, x̄::AbstractVector)</code></pre><p>Converts solution <span>$\bar {\rm x}$</span> computed in standard form back to general form  <span>${\rm x}$</span> using (Hansen, 1998). Solution is truncated to regularized space, given by the matrix L. If L is p × n and p &lt; n, then only the solution 1:p is valid. The remaining  parameters can be estiamted from the least-squares solution if needed.</p><div>\[{\rm x}={\rm {\bf L^{+}_A}\bar{x}}\]</div><p>where the matrices and vectors are defined in <a href="#RegularizationProblem">RegularizationProblem</a></p><p>Example Usage (Regular Syntax)</p><pre><code class="language-julia">x = to_general_form(Ψ, b, x̄) </code></pre><p>Example Usage (Lazy Syntax)</p><pre><code class="language-julia">x = @&gt;&gt; x̄ to_general_form(Ψ, b) </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/solvers.jl#L82-L105">source</a></section></article><h2 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h2><h3 id="Solve"><a class="docs-heading-anchor" href="#Solve">Solve</a><a id="Solve-1"></a><a class="docs-heading-anchor-permalink" href="#Solve" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.solve" href="#RegularizationTools.solve"><code>RegularizationTools.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solve(Ψ::RegularizationProblem, b̄::AbstractVector, λ::AbstractFloat)</code></pre><p>Compute the Tikhonov solution for problem Ψ in standard form for regularization parameter λ and using zero as initial guess. Returns a vector <span>$\rm {\bar x}_\lambda$</span>. </p><div>\[{\rm x_{\lambda}}=\left({\rm {\bf \bar A}^{T}}{\rm {\bf \bar A}}+\lambda^{2}{\rm {\bf I}}\right)^{-1} 
{\rm {\bf {\bar A}}^{T}}{\rm {\bar b}} \]</div><p>Example Usage (Standard Syntax)</p><pre><code class="language-julia"># A is a Matrix and b is a response vector. 
Ψ = setupRegularizationProblem(A, 1)     # Setup problem
b̄ = to_standard_form(Ψ, b)               # Convert to standard form
x̄ = solve(A, b̄, 0.5)                     # Solve the equation
x = to_general_form(Ψ, b, x̄)             # Convert back to general form</code></pre><p>Example Usage (Lazy Syntax)</p><pre><code class="language-julia"># A is a Matrix and b is a response vector. 
Ψ = setupRegularizationProblem(A, 1)     # Setup problem
b̄ = @&gt;&gt; b to_standard_form(Ψ)            # Convert to standard form
x̄ = solve(A, b̄, 0.5)                     # Solve the equation
x = @&gt;&gt; x̄ to_general_form(Ψ, b)          # Convert back to general form</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/solvers.jl#L116-L143">source</a></section><section><div><pre><code class="language-none">solve(Ψ::RegularizationProblem, b̄::AbstractVector, x̄₀::AbstractVector, λ::AbstractFloat)</code></pre><p>Compute the Tikhonov solution for problem Ψ in standard form for regularization parameter λ and using x̄₀ as initial guess. </p><div>\[{\rm x_{\lambda}}=\left({\rm {\bf \bar A}^{T}}{\rm {\bf \bar A}}+\lambda^{2}{\rm {\bf I}}\right)^{-1} 
\left({\rm {\bf {\bar A}}^{T}}{\rm {\bar b}} + \lambda^2 {\rm {\bar x}}_0 \right)\]</div><p>Example Usage (Standard Syntax)</p><pre><code class="language-julia"># A is a Matrix and b is a response vector. 
Ψ = setupRegularizationProblem(A, 2)     # Setup problem
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)       # Convert to standard form
x̄ = solve(A, b̄, x̄₀, 0.5)                 # Solve the equation
x = to_general_form(Ψ, b, x̄)             # Convert back to general form</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/solvers.jl#L147-L166">source</a></section><section><div><pre><code class="language-none">function solve(
    Ψ::RegularizationProblem,
    b::AbstractVector;
    alg = :gcv_svd,
    λ₁ = 0.0001,
    λ₂ = 1000.0,
)</code></pre><p>Find the optimum regularization parameter λ between [λ₁, λ₂] using the algorithm alg. Choices for algorithms are</p><pre><code class="language-none">    :gcv_tr - generalized cross validation using the trace formulation (slow)
    :gcv_svd - generalized cross validation using the SVD decomposition (fast)
    :L_curve - L-curve algorithm </code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The gcv_svd algorithm is fastest and most stable. The L_curve algorithn is sensitive to the upper  and lower bound. Specify narrow upper and lower bounds to obtain a good solution.</p></div></div><p>The solve function takes the original data, converts it to standard form, performs the search within the specified bounds and returns a <a href="#RegularizatedSolution">RegularizatedSolution</a></p><p>Example Usage (Standard Syntax)</p><pre><code class="language-julia"># A is a Matrix and b is a response vector. 
Ψ = setupRegularizationProblem(A, 2)     # Setup problem
sol = solve(Ψ, b)                        # Solve it</code></pre><p>Example Usage (Lazy Syntax)</p><pre><code class="language-julia"># A is a Matrix and b is a response vector. 
sol = @&gt; setupRegularizationProblem(A, 1) solve(b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/solvers.jl#L171-L207">source</a></section><section><div><pre><code class="language-none">function solve(
    Ψ::RegularizationProblem,
    b::AbstractVector,
    x₀::AbstractVector;
    alg = :gcv_svd,
    λ₁ = 0.0001,
    λ₂ = 1000.0,
)</code></pre><p>Same as above, but includes an initial guess x₀. Example Usage (Lazy Syntax)</p><pre><code class="language-julia"># A is a Matrix and b is a response vector. 
sol = @&gt; setupRegularizationProblem(A, 1) solve(b, x₀, alg = :L_curve, λ₂ = 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/solvers.jl#L232-L247">source</a></section><section><div><pre><code class="language-none">function solve(
    Ψ::RegularizationProblem, 
    b::AbstractVector,
    lower::AbstractVector, 
    upper::AbstractVector;
    kwargs...
)</code></pre><p>Constraint minimization of <a href="#RegularizationProblem">RegularizationProblem</a> Ψ, with observations b and upper and lower bounds for each xᵢ.</p><p>The function computes the algebraic solution using <code>solve(Ψ, b; kwargs...)</code>, truncates the solution at the upper and lower bounds and uses this solution as initial condition for the minimization problem using a Least Squares numerical solver. The returned solution is using the regularization parameter λ obtained from the algebraic solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/solvers.jl#L274-L290">source</a></section><section><div><pre><code class="language-none">function solve(
    Ψ::RegularizationProblem, 
    b::AbstractVector,
    x₀::AbstractVector,
    lower::AbstractVector, 
    upper::AbstractVector;
    kwargs...
)</code></pre><p>Constraint minimization of <a href="#RegularizationProblem">RegularizationProblem</a> Ψ, with observations b, intial  guess x₀ and upper and lower bounds for each xᵢ.</p><p>The function computes the algebraic solution using <code>solve(Ψ, b; kwargs...)</code>, truncates the solution at the upper and lower bounds and uses this solution as initial condition for the minimization problem using a Least Squares numerical solver. The returned solution is using the regularization parameter λ obtained from the algebraic solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/solvers.jl#L301-L319">source</a></section></article><h2 id="Validators"><a class="docs-heading-anchor" href="#Validators">Validators</a><a id="Validators-1"></a><a class="docs-heading-anchor-permalink" href="#Validators" title="Permalink"></a></h2><h3 id="GCV"><a class="docs-heading-anchor" href="#GCV">GCV</a><a id="GCV-1"></a><a class="docs-heading-anchor-permalink" href="#GCV" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.gcv_tr" href="#RegularizationTools.gcv_tr"><code>RegularizationTools.gcv_tr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gcv_tr(Ψ::RegularizationProblem, b̄::AbstractVector, λ::AbstractFloat)</code></pre><p>Compute the <a href="../theory/theory/#Generalized-Cross-Validation">Generalized Cross Validation</a> using the trace term. Requires that the  vector b̄ is in standard form.</p><div>\[V(\lambda)=\frac{n\left\lVert ({\bf {\rm {\bf {\bf I}-}{\bf \bar {A}_{\lambda}})
{\bar{\rm b}}}}\right\rVert _{2}^{2}}{tr({\rm {\bf I}-{\rm {\bar {\bf A}_{\lambda}})}^{2}}}\]</div><p>Example Usage</p><pre><code class="language-julia">using Underscores

Ψ = setupRegularizationProblem(A, 1)           # Setup problem
b̄ = to_standard_form(Ψ, b)                     # Convert to standard form
Vλ = gcv_tr(Ψ, b̄, 0.1)                         # V(λ) single λ value
Vλ = @_ map(gcv_tr(Ψ, b̄, _), [0.1, 1.0, 10.0]) # V(λ) for array of λ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/validators.jl#L1-L21">source</a></section><section><div><pre><code class="language-none">gcv_tr(
    Ψ::RegularizationProblem,
    b̄::AbstractVector,
    x̄₀::AbstractVector,
    λ::AbstractFloat,
)</code></pre><p>Compute the <a href="../theory/theory/#Generalized-Cross-Validation">Generalized Cross Validation</a> using the trace term and intial guess.  Requires that the vectors b̄ and x̄₀ are in standard form.</p><div>\[V(\lambda)=\frac{n\left\lVert {\bf {\rm {\bf \bar{A}}{\rm \bar{x}{}_{\lambda}}-
{\rm \bar{b}}}}\right\rVert _{2}^{2}}{tr({\rm {\bf I}-{\rm {\bar {\bf A}_{\lambda}})}^{2}}}\]</div><p>Example Usage</p><pre><code class="language-julia">using Underscores

Ψ = setupRegularizationProblem(A, 1)               # Setup problem
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)                 # Convert to standard form
Vλ = gcv_tr(Ψ, b̄, x̄₀, 0.1)                         # V(λ) single λ value
Vλ = @_ map(gcv_tr(Ψ, b̄, x̄₀, _), [0.1, 1.0, 10.0]) # V(λ) for array of λ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/validators.jl#L29-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.gcv_svd" href="#RegularizationTools.gcv_svd"><code>RegularizationTools.gcv_svd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gcv_svd(Ψ::RegularizationProblem, b̄::AbstractVector, λ::AbstractFloat)</code></pre><p>Compute the <a href="../theory/theory/#Generalized-Cross-Validation">Generalized Cross Validation</a> using the trace term using the SVD  algorithm. Requires that the vector b̄ is in standard form.</p><p>Example Usage</p><pre><code class="language-julia">using Underscores

Ψ = setupRegularizationProblem(A, 1)            # Setup problem
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)              # Convert to standard form
Vλ = gcv_svd(Ψ, b̄, x̄₀, 0.1)                     # V(λ) single λ value
Vλ = @_ map(gcv_svd(Ψ, b̄, _), [0.1, 1.0, 10.0]) # V(λ) for array of λ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/validators.jl#L67-L82">source</a></section><section><div><pre><code class="language-none">gcv_svd(
    Ψ::RegularizationProblem,
    b̄::AbstractVector,
    x̄₀::AbstractVector,
    λ::AbstractFloat,
)</code></pre><p>Compute the <a href="../theory/theory/#Generalized-Cross-Validation">Generalized Cross Validation</a> using the SVD algorithm and intial guess.  Requires that the vectors b̄ and x̄₀ are in standard form.</p><p>Example Usage</p><pre><code class="language-julia">using Underscores

Ψ = setupRegularizationProblem(A, 1)               # Setup problem
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)                 # Convert to standard form
Vλ = gcv_tr(Ψ, b̄, x̄₀, 0.1)                         # V(λ) single λ value
Vλ = @_ map(gcv_tr(Ψ, b̄, x̄₀, _), [0.1, 1.0, 10.0]) # V(λ) for array of λ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/validators.jl#L102-L122">source</a></section></article><h3 id="L-curve-Functions"><a class="docs-heading-anchor" href="#L-curve-Functions">L-curve Functions</a><a id="L-curve-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#L-curve-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RegularizationTools.Lcurve_functions" href="#RegularizationTools.Lcurve_functions"><code>RegularizationTools.Lcurve_functions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lcurve_functions(Ψ::RegularizationProblem, b̄::AbstractVector)</code></pre><p>Compute the L-curve functions to evaluate the norms L1, L2, and the curvature κ.  Requires that the vectors b̄ is in standard form.</p><p>Example Usage</p><pre><code class="language-julia">Ψ = setupRegularizationProblem(A, 1)
b̄ = to_standard_form(Ψ, b)
L1norm, L2norm, κ = Lcurve_functions(Ψ, b̄)

L1norm.([0.1, 1.0, 10.0])    # L1 norm for λ&#39;s
L2norm.([0.1, 1.0, 10.0])    # L2 norm for λ&#39;s
κ.([0.1, 1.0, 10.0])         # L-curve curvature for λ&#39;s</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/validators.jl#L160-L177">source</a></section><section><div><pre><code class="language-none">Lcurve_functions(Ψ::RegularizationProblem, b̄::AbstractVector, x̄₀::AbstractVector)</code></pre><p>Compute the L-curve functions to evaluate the norms L1, L2, and the curvature κ.  Requires that the vectors b̄ and x̄₀ are in standard form.</p><p>Example Usage</p><pre><code class="language-julia">Ψ = setupRegularizationProblem(A, 1)
b̄, x̄₀ = to_standard_form(Ψ, b, x₀)                 
L1norm, L2norm, κ = Lcurve_functions(Ψ, b̄, x̄₀)

L1norm.([0.1, 1.0, 10.0])    # L1 norm for λ&#39;s
L2norm.([0.1, 1.0, 10.0])    # L2 norm for λ&#39;s
κ.([0.1, 1.0, 10.0])         # L-curve curvature for λ&#39;s</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mdpetters/RegularizationTools.jl/blob/af987f017a29f4237dcf4f6e4bf7adb477494179/src/validators.jl#L185-L201">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theory/theory/">« Theory</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 2 October 2020 15:18">Friday 2 October 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
